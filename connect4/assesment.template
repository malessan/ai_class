#include <vector>
#include <cassert>
#include <algorithm>

namespace steffen_space{
    template<int width = 7, int height = 6, int connect = 4>
    assesment<width, height, connect>::assesment(){
        current_grid = std::array<std::array<char, height>, width>();
    }

    template<int width = 7, int height = 6, int connect = 4>
    float assesment<width, height, connect>::utility(std::array<std::array<char, height>, width> grid, int x, int y, char turn){
        assert(grid.size() > 0);
        // check invalid moves
        if (y < 0 || y >= (int)grid[0].size() || x < 0 || x >= (int)grid.size()){
            return 0;
        }

        // check vertical
        char prev_value = 0;
        int count = 0;
        for (size_t i = 0; i < grid[x].size(); i++){
            char value = grid[x][i];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect && value != empty_value){
                    return 1000;
                }
            }
        }

        // check horizontal
        prev_value = 0;
        count = 0;
        for (size_t i = 0; i < grid.size(); i++){
            char value = grid[i][y];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect && value != empty_value){
                    return 1000;
                }
            }
        }

        // check diagonals
        // start from bottom-left
        count = 0;
        prev_value = 0;
        int Min = std::min(x,y);
        int row = x - Min;
        int col = y - Min;
        while(row < (int)grid.size() && col < (int)grid[row].size()){
            char value = grid[row][col];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect && value != empty_value){
                    return 1000;
                }
            }
            ++row;
            ++col;
        }

        // start from bottom-right
        count = 0;
        prev_value = 0;
        Min = std::min(grid.size()-1 - x,y);
        row = x + Min;
        col = y - Min;
        while(row >= 0 && col < (int)grid[row].size()){
            char value = grid[row][col];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect && value != empty_value){
                    return 1000;
                }
            }
            --row;
            ++col;
        }
        
        // there is no 4 in a row
        return 0;
    }


}
