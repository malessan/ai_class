#include <vector>
#include <cassert>

namespace steffen_space{
    template<class type>
    int utility(std::vector< std::vector<type> > grid, int x, int y, type turn){
        assert(grid.size() > 0);
        // check vertical
        type prev_value = 0;
        int count = 0;
        for (size_t i = 0; i < grid[x].size(); i++)
        {
            type value = grid[x][i];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect_length && value != empty_value){
                    if(value == turn){
                        return 1000;
                    }
                    else{
                        return -1000;
                    }
                }
            }
        }

        // check horizontal
        prev_value = 0;
        count = 0;
        for (size_t i = 0; i < grid.size(); i++)
        {
            type value = grid[i][y];
            if(value != prev_value){
                count = 1;
                prev_value = value;
            }
            else{
                if(++count >= connect_length && value != empty_value){
                    if(value == turn){
                        return 1000;
                    }
                    else{
                        return -1000;
                    }
                }
            }
        }

        // check diagonals
        // start from bottom-left -- row side
        for(size_t i=0; i <= grid.size() - connect_length; ++i){
            count = 0;
            prev_value = 0;
            int row = i;
            int col = 0;
            while(row < (int)grid.size() && col < (int)grid[row].size()){
                type value = grid[row][col];
                if(value != prev_value){
                    count = 1;
                    prev_value = value;
                }
                else{
                    if(++count >= connect_length && value != empty_value){
                        if(value == turn){
                            return 1000;
                        }
                        else{
                            return -1000;
                        }
                    }
                }
                ++row;
                ++col;
            }
        }
        // start from bottom-left -- col side
        for(size_t i=1; i <= grid[x].size() - connect_length; ++i){
            count = 0;
            prev_value = 0;
            int row = 0;
            int col = i;
            while(row < (int)grid[x].size() && col < (int)grid.size()){
                type value = grid[row][col];
                if(value != prev_value){
                    count = 1;
                    prev_value = value;
                }
                else{
                    if(++count >= connect_length && value != empty_value){
                        if(value == turn){
                            return 1000;
                        }
                        else{
                            return -1000;
                        }
                    }
                }
                ++row;
                ++col;
            }
        }
        // start from bottom-right -- row side
        for(int i=grid.size()-1; i >= connect_length-1; --i){
            count = 0;
            prev_value = 0;
            int row = i;
            int col = 0;
            while(row >= 0 && col < (int)grid[row].size()){
                type value = grid[row][col];
                if(value != prev_value){
                    count = 1;
                    prev_value = value;
                }
                else{
                    if(++count >= connect_length && value != empty_value){
                        if(value == turn){
                            return 1000;
                        }
                        else{
                            return -1000;
                        }
                    }
                }
                --row;
                ++col;
            }
        }
        // start from bottom-right -- col side
        for(int i=1; i <= (int)grid[x].size() - connect_length; ++i){
            count = 0;
            prev_value = 0;
            int row = grid.size()-1;
            int col = i;
            while(row >= 0 && col < (int)grid.size()){
                type value = grid[row][col];
                if(value != prev_value){
                    count = 1;
                    prev_value = value;
                }
                else{
                    if(++count >= connect_length && value != empty_value){
                        if(value == turn){
                            return 1000;
                        }
                        else{
                            return -1000;
                        }
                    }
                }
                --row;
                ++col;
            }
        }
        return 0;
    }


}
