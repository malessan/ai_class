// The node for holding the state space
#ifndef _STATE_SPACE_H_
#define _STATE_SPACE_H_
#include <array>
#include <algorithm>
#include <string>

namespace steffen_space{
    template<int width, int height>
    grid_state<width,height>::grid_state()
    : grid()
    {
        score = 0;
        input = -1;
    }
    template<int width, int height>
    grid_state<width,height>::grid_state(float score, int input)
    : grid()
    {
        this.score = score;
        this.input = input;
    }

    template<int width, int height>
    grid_state<width, height> grid_state<width,height>::copy(){
        grid_state<width, height, connect> new_grid();
        for (size_t i = 0; i < grid.size(); i++)
        {
            for (size_t j = 0; j < grid[i].size(); j++)
            {
                new_grid[i][j] = grid[i][j];
            }
        }
        return new_grid;
    }

    template<int width, int height>
    std::array<std::array<char, height>, width> grid_state<width,height>::get_grid(){
        return grid;
    }

    template<int width, int height>
    size_t grid_state<width,height>::set_data(char value, size_t x){
        int input = 0;
        if(value == 'O'){
            input = 1;
        }
        else if(value == 'X'){
            input = 2;
        }
        return set_data(input, x);
    }

    template<int width, int height>
    size_t grid_state<width,height>::set_data(int value, size_t x){
        if(x < grid.size()){
            int y = this.get_height_empty((int)x);
            if(y != -1){
                switch(value){
                    case 1:
                        grid[x][y] = 'O';
                        break;
                    case 2:
                        grid[x][y] = 'X';
                        break;
                    default:
                        grid[x][y] = '.';
                        break;
                }
            }
            return y;
        }
        return -1;
    }

    template<int width, int height>
    float grid_state<width,height>::get_score(){
        return score;
    }
    template<int width, int height>
    void grid_state<width,height>::set_score(float value){
        score = value;
    }

    template<int width, int height>
    int grid_state<width,height>::get_input(){
        return input;
    }
    template<int width, int height>
    void grid_state<width,height>::set_input(int value){
        input = value;
    }

    template<int width, int height>
    int grid_state<width,height>::get_height_empty(int x){
        int y = -1;
        for (size_t i = 0; i < grid[x].size(); i++)
        {
            if(grid[x][i] == '.'){
                y = (int)i;
                break;
            }
        }
        return y;
    }

    template<int width, int height>
    std::string grid_state<width,height>::to_string(){
        std::string output = "";
        for (int j = grid[0].size()-1; j >= 0; --j)
        {
            for (size_t i = 0; i < grid.size(); ++i)
            {
                output += grid[i][j];
            }
            output += "\n";
        }
        return output;
    }
}

#endif

