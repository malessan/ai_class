#include <iostream>
#include <queue>
#include <cstdlib>
#include <iomanip>


namespace steffen_space
{
	/// Constructor: empty 		-set as root where data is "ROOT"
	///				 overloaded -set parent and data
	template<class unit>
	tree_node::tree_node()
	: children()
	{
		data = unit();
	}
	template<class unit>
	tree_node::tree_node(const unit& init_data)
	: children()
	{
		data = init_data;
	}
	template<class unit>
	tree_node::tree_node(const unit& init_data, vector<tree_node*> _children)
	{
		data = init_data;
		children = _children;
	}
	/*
	/// Insert new child
	node_class* tree_class::new_child(node_class &_parent, std::string _behavior, std::string _response){
		node_class* new_node = new node_class();
		new_node->new_child(_parent, _behavior, _response);
		return new_node;
	}
	node_class* tree_class::new_child(std::string _behavior, std::string _response){
		return new_child(*root, _behavior, _response);
	}
	*/
	/// Depth first search (preorder)
	template <class process, class node_class>
	void depth_search(process f, node_class* node){
		if(node != NULL){
			f(node->get_data());
			for(size_t i=0; i < node->get_num_children(); i++){
				depth_search(f, node->get_child(i));
			}
		}
	}

	/// Breadth first search
	template <class process, class node_class>
	void breadth_search(process f, node_class* node){
		if(node != NULL){
			std::queue<node_class*> list;
			while(!list.empty()){
				node_class* top = list.front();
				list.pop();
				f(top->get_data());
				for(size_t i=0; i < top->get_num_children(); i++){
					list.push(top->get_child(i));
				}
			}
		}
	}

	/// Print tree
	template <class unit, class size_type>
    void print(tree_node<Item>* node, size_type depth){
		if(node != NULL){
			std::cout << std::setw(4*depth) << node->get_data().get_print() << std::endl;
			for(size_t i=0; i < node->get_num_children(); i++){
				print(node->get_child(i), depth+1);
			}
		}
	}
	template <class unit>
    void print(binary_tree_node<Item>* node){
		int depth = 0;
		print(node, depth);
	}

}
