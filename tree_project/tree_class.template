#include <iostream>
#include <vector>
#include "tree_class.h"


namespace steffen_space{

	/// Constructor: empty 		-set as root where data is "ROOT"
	///				 overloaded -set parent and data
	template<class unit>
	tree_node::tree_node()
	: children()
	{
		data = unit();
		parent = NULL;
	}
	template<class unit>
	tree_node::tree_node(tree_node* init_parent, const unit& init_data)
	: children()
	{
		data = init_data;
		parent = init_parent;
	}
	/// Destructor: delete parent and children
	template<class unit>
	tree_class::~tree_class (){
		delete root;
	}
	/*
	/// Insert new child
	node_class* tree_class::new_child(node_class &_parent, std::string _behavior, std::string _response){
		node_class* new_node = new node_class();
		new_node->new_child(_parent, _behavior, _response);
		return new_node;
	}
	node_class* tree_class::new_child(std::string _behavior, std::string _response){
		return new_child(*root, _behavior, _response);
	}
	*/
	/// Depth first search (preorder)
	template <class process, class node_class>
	void depth_search(process f, node_class* node){
		if(node != NULL){
			f(node->get_data());
			for(size_t i=0; i < node->get_num_children(); i++){
				depth_search(f, node->get_child(i));
			}
		}
	}

	/// Breadth first search
	template <class process, class node_class>
	void breadth_search(process f, node_class* node){
		if(node != NULL){
			std::queue<node_class*> list;
			while(!list.empty()){
				node_class* top = list.front();
				list.pop();
				f(top->get_data());
				for(size_t i=0; i < top->get_num_children(); i++){
					list.push(top->get_child(i));
				}
			}
		}
	}

	/// returns string from the print functions
	std::string tree_class::get_print(){
		std::string output;
		node_class* current_node;
		current_node = root;
		// check through tree, append string of behavior and response to output string
		while(current_node){

		}
	}
}
